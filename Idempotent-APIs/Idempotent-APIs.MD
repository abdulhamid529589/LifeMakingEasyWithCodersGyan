# Idempotent APIs - Complete Guide

## Introduction

This guide covers **Idempotency** in APIs - a critical concept for production systems that prevents duplicate records, double charges, and data corruption. Learn what idempotent APIs are, why they're essential, and how to implement them properly.

---

## Table of Contents

1. [What is Idempotency?](#what-is-idempotency)
2. [The Problem Without Idempotency](#the-problem-without-idempotency)
3. [HTTP Methods and Idempotency](#http-methods-and-idempotency)
4. [Implementation Strategy](#implementation-strategy)
5. [Best Practices](#best-practices)
6. [Real-World Examples](#real-world-examples)

---

## What is Idempotency?

### Definition

> **Idempotent Operation**: Performing the same action multiple times produces the same effect as performing it once.

### In API Context:

**An API endpoint is idempotent when:**
- Making the same request multiple times with the same data
- Results in the same state as making it once
- No duplicate records or side effects

### Example:

```javascript
// Idempotent behavior
createUser({ email: "user@example.com" })  // Creates user
createUser({ email: "user@example.com" })  // Returns existing user (no duplicate)
createUser({ email: "user@example.com" })  // Returns existing user (no duplicate)

// Result: Only ONE user exists
```

### Why It Matters:

âœ… **Prevents duplicate records**
âœ… **Avoids double charges in payment systems**
âœ… **Enables safe retries after failures**
âœ… **Critical for production systems**

---

## The Problem Without Idempotency

### Scenario: Payment System Without Idempotency

Let's visualize what happens when APIs aren't idempotent:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚                                    â”‚ Server  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                                              â”‚
     â”‚  POST /pay                                   â”‚
     â”‚  { user: "Alice", amount: 100 }             â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                              â”‚
     â”‚                                         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
     â”‚                                         â”‚ Validate â”‚
     â”‚                                         â”‚ Request  â”‚
     â”‚                                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚                                              â”‚
     â”‚                                         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
     â”‚                                         â”‚  Store   â”‚
     â”‚                                         â”‚  in DB   â”‚
     â”‚                                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚                                              â”‚
     â”‚                                     âœ… Payment Record Created
     â”‚                                              â”‚
     â”‚                                         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
     â”‚                                         â”‚ Notify   â”‚
     â”‚                                         â”‚ User     â”‚
     â”‚                                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚                                              â”‚
     â”‚                                         âŒ Error! (Network/Service down)
     â”‚                                              â”‚
     â”‚  500 Internal Server Error                  â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚                                              â”‚
     â”‚  âš ï¸ Client sees error, retries...            â”‚
     â”‚                                              â”‚
     â”‚  POST /pay (RETRY 1)                        â”‚
     â”‚  { user: "Alice", amount: 100 }             â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                              â”‚
     â”‚                                         Validate âœ…
     â”‚                                         Store in DB âœ…
     â”‚                                              â”‚
     â”‚                                     âŒ DUPLICATE Payment Created!
     â”‚                                              â”‚
     â”‚  500 Internal Server Error                  â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚                                              â”‚
     â”‚  âš ï¸ Client retries again...                  â”‚
     â”‚                                              â”‚
     â”‚  POST /pay (RETRY 2)                        â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                              â”‚
     â”‚                                     âŒ ANOTHER Duplicate Payment!
     â”‚                                              â”‚
```

### Result: Disaster! ğŸ’¥

```
Database state:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User   â”‚ Amount â”‚ Status         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Alice  â”‚ 100    â”‚ Created âœ…      â”‚
â”‚ Alice  â”‚ 100    â”‚ Created âŒ DUP â”‚
â”‚ Alice  â”‚ 100    â”‚ Created âŒ DUP â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Total charged: $300 instead of $100!
```

### Problems Caused:

âŒ **Double/Triple charging customers**
âŒ **Duplicate database records**
âŒ **Data corruption**
âŒ **Customer complaints**
âŒ **Refund processing overhead**
âŒ **Loss of trust**

---

## HTTP Methods and Idempotency

### RFC 9110 HTTP Semantics Specification

According to [RFC 9110 Section 9.2.2](https://www.rfc-editor.org/rfc/rfc9110.html#section-9.2.2):

> "A request method is considered idempotent if the intended effect on the server of multiple identical requests with that method is the same as the effect for a single such request."

### Idempotent by Default

| Method | Idempotent? | Explanation |
|--------|-------------|-------------|
| **GET** | âœ… Yes | Reading data doesn't change state |
| **PUT** | âœ… Yes | Updating to same value multiple times = same result |
| **DELETE** | âœ… Yes | Deleting same resource multiple times = same result |
| **HEAD** | âœ… Yes | Same as GET, no body |
| **OPTIONS** | âœ… Yes | Returns available methods |

### NOT Idempotent by Default

| Method | Idempotent? | Explanation |
|--------|-------------|-------------|
| **POST** | âŒ No | Creates new resource each time |
| **PATCH** | âš ï¸ Depends | Depends on implementation |

### Examples:

#### GET (Naturally Idempotent)
```javascript
// Call it 1 time or 1000 times - same result
GET /users/123
GET /users/123  // Same user returned
GET /users/123  // Same user returned
```

#### PUT (Naturally Idempotent)
```javascript
// Setting to same value multiple times
PUT /users/123
{ "name": "Alice" }

PUT /users/123  // Still "Alice"
{ "name": "Alice" }

// Result: User name is "Alice" (not changed twice)
```

#### DELETE (Naturally Idempotent)
```javascript
DELETE /users/123  // User deleted
DELETE /users/123  // Already deleted (no error, same state)
DELETE /users/123  // Still deleted
```

#### POST (NOT Idempotent by Default)
```javascript
POST /users  // Creates User 1
POST /users  // Creates User 2 (duplicate!)
POST /users  // Creates User 3 (duplicate!)

// Result: 3 duplicate users âŒ
```

### HTTP Specification on Retries

From RFC 9110:

> **"A client SHOULD NOT automatically retry a request with a non-idempotent method"**

This is why POST requests need special handling!

---

## Implementation Strategy

### The Solution: Idempotency Keys

The standard approach to make POST requests idempotent:

### How It Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Client  â”‚                                    â”‚ Server  â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚                                              â”‚
     â”‚ 1. Generate UUID                             â”‚
     â”‚ idempotencyKey = "uuid-123-456"             â”‚
     â”‚                                              â”‚
     â”‚ 2. POST /pay                                 â”‚
     â”‚    Headers:                                  â”‚
     â”‚      Idempotency-Key: "uuid-123-456"        â”‚
     â”‚    Body: { user: "Alice", amount: 100 }     â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                              â”‚
     â”‚                                         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                                         â”‚ Check Cache  â”‚
     â”‚                                         â”‚ for Key?     â”‚
     â”‚                                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                                              â”‚
     â”‚                                         Key NOT found
     â”‚                                         (first request)
     â”‚                                              â”‚
     â”‚                                         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
     â”‚                                         â”‚ Validate â”‚
     â”‚                                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚                                              â”‚
     â”‚                                         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
     â”‚                                         â”‚ Store    â”‚
     â”‚                                         â”‚ in DB    â”‚
     â”‚                                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚                                              â”‚
     â”‚                                     âœ… Payment Created
     â”‚                                              â”‚
     â”‚                                         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                                         â”‚ Store Key     â”‚
     â”‚                                         â”‚ in Cache      â”‚
     â”‚                                         â”‚ (Redis/Memory)â”‚
     â”‚                                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                                              â”‚
     â”‚                                         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
     â”‚                                         â”‚ Notify   â”‚
     â”‚                                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
     â”‚                                              â”‚
     â”‚                                         âŒ Error!
     â”‚                                              â”‚
     â”‚  500 Error                                   â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚                                              â”‚
     â”‚  âš ï¸ Retry with SAME idempotency key          â”‚
     â”‚                                              â”‚
     â”‚  POST /pay                                   â”‚
     â”‚    Headers:                                  â”‚
     â”‚      Idempotency-Key: "uuid-123-456"        â”‚
     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
     â”‚                                              â”‚
     â”‚                                         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                                         â”‚ Check Cache  â”‚
     â”‚                                         â”‚ for Key?     â”‚
     â”‚                                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                                              â”‚
     â”‚                                         âœ… Key FOUND!
     â”‚                                         (duplicate request)
     â”‚                                              â”‚
     â”‚                                         â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
     â”‚                                         â”‚ Return cached â”‚
     â”‚                                         â”‚ response      â”‚
     â”‚                                         â”‚ (no DB write) â”‚
     â”‚                                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚                                              â”‚
     â”‚  200 OK (from cache)                        â”‚
     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
     â”‚                                              â”‚
```

### Result: Success! âœ…

```
Database state:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ User   â”‚ Amount â”‚ Status â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Alice  â”‚ 100    â”‚ Createdâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Only ONE payment record!
All retries returned cached response.
```

---

## Implementation Details

### Step 1: Client-Side (Frontend)

Generate unique ID and send as header:

```javascript
// React/JavaScript example
import { v4 as uuidv4 } from 'uuid';

async function createPayment(paymentData) {
  // Generate unique idempotency key
  const idempotencyKey = uuidv4();
  // Example: "a3bb189e-8bf9-3888-9912-ace4e6543002"
  
  try {
    const response = await fetch('/api/pay', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Idempotency-Key': idempotencyKey  // â† Key header
      },
      body: JSON.stringify(paymentData)
    });
    
    return await response.json();
  } catch (error) {
    // On error, retry with SAME idempotency key
    console.error('Payment failed, retrying with same key...');
    // Retry logic here with same idempotencyKey
  }
}

// Usage
createPayment({
  user: 'Alice',
  amount: 100,
  currency: 'USD'
});
```

### Step 2: Server-Side (Backend)

Check cache and store key:

```javascript
// Express.js example
const express = require('express');
const NodeCache = require('node-cache');

const app = express();
const cache = new NodeCache({ stdTTL: 86400 }); // 24 hours

app.post('/api/pay', async (req, res) => {
  try {
    // 1. Extract idempotency key from header
    const idempotencyKey = req.headers['idempotency-key'];
    
    if (!idempotencyKey) {
      return res.status(400).json({ 
        error: 'Idempotency-Key header required' 
      });
    }
    
    // 2. Check if key exists in cache
    const cachedResponse = cache.get(idempotencyKey);
    
    if (cachedResponse) {
      console.log('Duplicate request detected, returning cached response');
      return res.status(cachedResponse.status).json(cachedResponse.data);
    }
    
    // 3. First time - process the request
    const { user, amount } = req.body;
    
    // Validate request
    if (!user || !amount) {
      return res.status(400).json({ error: 'Invalid request' });
    }
    
    // Store payment in database
    const payment = await db.payments.create({
      user,
      amount,
      status: 'completed'
    });
    
    // 4. Store idempotency key in cache IMMEDIATELY after DB write
    cache.set(idempotencyKey, {
      status: 201,
      data: { 
        message: 'Payment created',
        payment 
      }
    });
    
    // 5. Notify user (may fail)
    try {
      await notifyUser(user, payment);
    } catch (notificationError) {
      console.error('Notification failed:', notificationError);
      // Payment already created and cached - safe to fail here
    }
    
    // 6. Return success response
    return res.status(201).json({
      message: 'Payment created',
      payment
    });
    
  } catch (error) {
    console.error('Payment error:', error);
    return res.status(500).json({ error: 'Payment failed' });
  }
});
```

### Step 3: Cache Implementation Options

#### Option 1: In-Memory Cache (Simple)
```javascript
const NodeCache = require('node-cache');
const cache = new NodeCache({ 
  stdTTL: 86400  // 24 hours
});
```

**Pros**: Simple, fast
**Cons**: Lost on server restart, doesn't work across multiple servers

#### Option 2: Redis (Production)
```javascript
const redis = require('redis');
const client = redis.createClient();

await client.connect();

// Store key with 24-hour expiration
await client.setEx(
  `idempotency:${idempotencyKey}`, 
  86400,  // 24 hours in seconds
  JSON.stringify(response)
);

// Check key
const cached = await client.get(`idempotency:${idempotencyKey}`);
```

**Pros**: Persistent, works across multiple servers, auto-expiration
**Cons**: Requires Redis infrastructure

---

## Best Practices

### 1. When to Store the Key

**âŒ Bad: Store at the end**
```javascript
// Problem: If error occurs before this, retry will duplicate
await db.create(payment);
await notify(user);
await cache.set(key, response);  // Too late!
```

**âœ… Good: Store immediately after critical operation**
```javascript
// Store right after database write
await db.create(payment);
await cache.set(key, response);  // âœ… Safe now!

// Even if notification fails, key is cached
await notify(user);  // Can fail safely
```

### 2. Cache Expiration (TTL)

**RFC 9110 Recommendation: 24 hours**

```javascript
// Redis with 24-hour expiration
await redis.setEx(key, 86400, data);

// Node-cache with 24-hour expiration
const cache = new NodeCache({ stdTTL: 86400 });
```

**Why 24 hours?**
- Most retries happen within seconds/minutes
- Balances storage costs with safety
- Industry standard

### 3. What to Cache

Store enough info to return meaningful response:

```javascript
cache.set(idempotencyKey, {
  status: 201,
  timestamp: Date.now(),
  data: {
    paymentId: payment.id,
    amount: payment.amount,
    status: payment.status
  }
});
```

### 4. Handle Missing Keys

```javascript
if (!idempotencyKey) {
  // For backward compatibility, allow requests without key
  // but log warning for monitoring
  console.warn('Request without idempotency key');
  // Continue processing...
}
```

### 5. Key Format

Use standard UUID format:

```javascript
// âœ… Good: UUID v4
const key = uuidv4();
// "a3bb189e-8bf9-3888-9912-ace4e6543002"

// âŒ Bad: Predictable patterns
const key = `${userId}-${Date.now()}`;  // Predictable!
```

---

## Real-World Examples

### Payment Processing

```javascript
// Stripe-like payment system
app.post('/api/payments', async (req, res) => {
  const idempotencyKey = req.headers['idempotency-key'];
  
  // Check cache
  const cached = await redis.get(`payment:${idempotencyKey}`);
  if (cached) {
    return res.json(JSON.parse(cached));
  }
  
  // Process payment
  const charge = await stripe.charges.create({
    amount: req.body.amount,
    currency: 'usd',
    source: req.body.token
  });
  
  // Cache immediately
  await redis.setEx(
    `payment:${idempotencyKey}`,
    86400,
    JSON.stringify(charge)
  );
  
  res.json(charge);
});
```

### User Registration

```javascript
app.post('/api/users', async (req, res) => {
  const idempotencyKey = req.headers['idempotency-key'];
  
  // Check cache
  const cached = await cache.get(idempotencyKey);
  if (cached) {
    return res.status(200).json(cached);  // Return existing user
  }
  
  // Check if user exists by email
  const existing = await db.users.findOne({ 
    email: req.body.email 
  });
  
  if (existing) {
    // Cache and return existing
    await cache.set(idempotencyKey, existing);
    return res.status(200).json(existing);
  }
  
  // Create new user
  const user = await db.users.create(req.body);
  
  // Cache the result
  await cache.set(idempotencyKey, user);
  
  res.status(201).json(user);
});
```

### Order Creation

```javascript
app.post('/api/orders', async (req, res) => {
  const idempotencyKey = req.headers['idempotency-key'];
  
  if (!idempotencyKey) {
    return res.status(400).json({ 
      error: 'Idempotency-Key required' 
    });
  }
  
  // Check cache
  const cached = await redis.get(`order:${idempotencyKey}`);
  if (cached) {
    return res.json(JSON.parse(cached));
  }
  
  // Create order
  const order = await db.orders.create({
    items: req.body.items,
    userId: req.user.id,
    total: calculateTotal(req.body.items)
  });
  
  // Cache before potentially failing operations
  await redis.setEx(
    `order:${idempotencyKey}`,
    86400,
    JSON.stringify(order)
  );
  
  // These can fail safely now
  await updateInventory(order.items);
  await sendConfirmationEmail(req.user.email, order);
  
  res.status(201).json(order);
});
```

---

## Common Pitfalls

### âŒ Pitfall 1: Caching Too Late

```javascript
// BAD: Cache after everything
await db.create(payment);
await notify(user);
await cache.set(key, response);  // If notify() fails, not cached!
```

**Solution**: Cache immediately after critical DB operation.

### âŒ Pitfall 2: Not Using TTL

```javascript
// BAD: Keys never expire
cache.set(key, data);  // Cache grows forever!
```

**Solution**: Always set expiration.

```javascript
// GOOD
cache.set(key, data, 86400);  // 24 hours
```

### âŒ Pitfall 3: Ignoring Network Errors

```javascript
// BAD: Retry on ALL errors
catch (error) {
  retry();  // Might duplicate!
}
```

**Solution**: Differentiate network vs server errors.

```javascript
// GOOD
catch (error) {
  if (error.code === 'ECONNREFUSED') {
    // Network error - safe to retry
    retry();
  } else if (error.status >= 500) {
    // Server error - might have processed
    // Use same idempotency key to retry safely
    retryWithSameKey();
  }
}
```

### âŒ Pitfall 4: Different Keys for Retries

```javascript
// BAD: New key each retry
function createPayment() {
  const key = uuidv4();  // New key every call!
  fetch('/pay', { headers: { 'Idempotency-Key': key } });
}

button.onClick(() => createPayment());  // Different key each click!
```

**Solution**: Generate key once, reuse for retries.

```javascript
// GOOD
let idempotencyKey = null;

function createPayment() {
  if (!idempotencyKey) {
    idempotencyKey = uuidv4();  // Generate once
  }
  
  return fetch('/pay', { 
    headers: { 'Idempotency-Key': idempotencyKey }
  });
}
```

---

## Testing Idempotency

### Test Cases

```javascript
describe('Payment Idempotency', () => {
  it('should create payment on first request', async () => {
    const key = uuidv4();
    
    const response = await fetch('/api/pay', {
      method: 'POST',
      headers: { 'Idempotency-Key': key },
      body: JSON.stringify({ amount: 100 })
    });
    
    expect(response.status).toBe(201);
    const data = await response.json();
    expect(data.payment).toBeDefined();
  });
  
  it('should return cached response on duplicate request', async () => {
    const key = uuidv4();
    
    // First request
    const response1 = await fetch('/api/pay', {
      method: 'POST',
      headers: { 'Idempotency-Key': key },
      body: JSON.stringify({ amount: 100 })
    });
    const data1 = await response1.json();
    
    // Duplicate request with same key
    const response2 = await fetch('/api/pay', {
      method: 'POST',
      headers: { 'Idempotency-Key': key },
      body: JSON.stringify({ amount: 100 })
    });
    const data2 = await response2.json();
    
    // Should return same payment
    expect(data1.payment.id).toBe(data2.payment.id);
    
    // Should only create one record
    const payments = await db.payments.findAll();
    expect(payments.length).toBe(1);
  });
  
  it('should create different payments with different keys', async () => {
    const key1 = uuidv4();
    const key2 = uuidv4();
    
    await fetch('/api/pay', {
      headers: { 'Idempotency-Key': key1 },
      body: JSON.stringify({ amount: 100 })
    });
    
    await fetch('/api/pay', {
      headers: { 'Idempotency-Key': key2 },
      body: JSON.stringify({ amount: 100 })
    });
    
    const payments = await db.payments.findAll();
    expect(payments.length).toBe(2);  // Two different payments
  });
});
```

---

## Architecture Patterns

### Pattern 1: Middleware Approach

```javascript
// idempotency-middleware.js
const checkIdempotency = (cache) => {
  return async (req, res, next) => {
    const key = req.headers['idempotency-key'];
    
    if (!key) {
      return next();  // Allow without key (optional)
    }
    
    // Check cache
    const cached = await cache.get(key);
    if (cached) {
      return res.status(cached.status).json(cached.data);
    }
    
    // Store response after handler completes
    const originalJson = res.json;
    res.json = function(data) {
      cache.set(key, { status: res.statusCode, data });
      originalJson.call(this, data);
    };
    
    next();
  };
};

// Usage
app.use(checkIdempotency(cache));
```

### Pattern 2: Decorator Pattern

```javascript
function idempotent(cache, ttl = 86400) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function(...args) {
      const [req, res] = args;
      const key = req.headers['idempotency-key'];
      
      if (key) {
        const cached = await cache.get(key);
        if (cached) return res.json(cached);
      }
      
      const result = await originalMethod.apply(this, args);
      
      if (key) {
        await cache.setEx(key, ttl, result);
      }
      
      return result;
    };
    
    return descriptor;
  };
}

// Usage
class PaymentController {
  @idempotent(redis)
  async createPayment(req, res) {
    // Implementation
  }
}
```

---

## Summary

### Key Takeaways

âœ… **Idempotency prevents duplicate operations** from retries
âœ… **GET, PUT, DELETE are naturally idempotent**
âœ… **POST requires explicit implementation** using idempotency keys
âœ… **Use unique UUIDs as idempotency keys**
âœ… **Cache keys with 24-hour expiration** (industry standard)
âœ… **Store keys immediately after critical operations**
âœ… **Essential for payment systems and production APIs**

### Implementation Checklist

- [ ] Generate UUID on client side
- [ ] Send as `Idempotency-Key` header
- [ ] Check cache before processing
- [ ] Store key after DB write
- [ ] Return cached response for duplicates
- [ ] Set 24-hour TTL
- [ ] Use Redis for production
- [ ] Test with multiple retries
- [ ] Monitor cache hit rates
- [ ] Document for API users

### When to Implement

**Critical for:**
- ğŸ’° Payment processing
- ğŸ’³ Order creation
- ğŸ‘¤ User registration
- ğŸ“§ Email/SMS sending
- ğŸ”„ Any operation that shouldn't duplicate

**Less critical for:**
- ğŸ“– Read operations (naturally idempotent)
- ğŸ” Search queries
- ğŸ“Š Analytics tracking

---

## Challenge

Implement idempotency in your project:

1. **Choose an endpoint** that creates resources
2. **Add UUID generation** on the frontend
3. **Implement cache checking** on the backend
4. **Test with retries** (manually or automated)
5. **Share your implementation** on LinkedIn and tag the creator

---

## Further Learning

### Resources
- [RFC 9110 - HTTP Semantics](https://www.rfc-editor.org/rfc/rfc9110.html)
- [Stripe API Idempotency](https://stripe.com/docs/api/idempotent_requests)
- [Production-Ready Full Stack Engineer Program](link) - Practical microservices implementation

### Related Topics
- **Distributed Systems**
- **Event Sourcing**
- **CQRS Pattern**
- **Saga Pattern**
- **Eventual Consistency**

---

**Happy Coding! ğŸš€**

*Production systems require idempotent APIs - implement them properly!*